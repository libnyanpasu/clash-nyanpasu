/** tauri-specta globals **/

import {
  Channel as TAURI_CHANNEL,
  invoke as TAURI_INVOKE,
} from '@tauri-apps/api/core'
import * as TAURI_API_EVENT from '@tauri-apps/api/event'
import { type WebviewWindow as __WebviewWindow__ } from '@tauri-apps/api/webviewWindow'

/* eslint-disable */
// @ts-nocheck
// This file was generated by [tauri-specta](https://github.com/oscartbeaumont/tauri-specta). Do not edit this file manually.

/** user-defined commands **/

export const commands = {
  /**
   * get the system proxy
   * server field is the combination of host and port
   */
  async getSysProxy(): Promise<Result<GetSysProxyResponse, string>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('get_sys_proxy') }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
  async openAppConfigDir(): Promise<Result<null, string>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('open_app_config_dir') }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
  async openAppDataDir(): Promise<Result<null, string>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('open_app_data_dir') }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
  async openLogsDir(): Promise<Result<null, string>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('open_logs_dir') }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
  async openWebUrl(url: string): Promise<Result<null, string>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('open_web_url', { url }) }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
  async openCoreDir(): Promise<Result<null, string>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('open_core_dir') }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
  /**
   * restart the sidecar
   */
  async restartSidecar(): Promise<Result<null, string>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('restart_sidecar') }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
  async getClashInfo(): Promise<Result<ClashInfo, string>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('get_clash_info') }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
  async getClashLogs(): Promise<Result<string[], string>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('get_clash_logs') }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
  /**
   * patch clash runtime config
   */
  async patchClashConfig(
    payload: PatchRuntimeConfig,
  ): Promise<Result<null, string>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('patch_clash_config', { payload }),
      }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
  async changeClashCore(
    clashCore: ClashCore | null,
  ): Promise<Result<null, string>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('change_clash_core', { clashCore }),
      }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
  /**
   * get the runtime config
   */
  async getRuntimeConfig(): Promise<Result<JsonValue | null, string>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('get_runtime_config') }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
  async getRuntimeYaml(): Promise<Result<string, string>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('get_runtime_yaml') }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
  async getRuntimeExists(): Promise<Result<string[], string>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('get_runtime_exists') }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
  async getPostprocessingOutput(): Promise<
    Result<PostProcessingOutput, string>
  > {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('get_postprocessing_output'),
      }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
  async clashApiGetProxyDelay(
    name: string,
    url: string | null,
  ): Promise<Result<DelayRes, string>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('clash_api_get_proxy_delay', { name, url }),
      }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
  async invokeUwpTool(): Promise<Result<null, string>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('invoke_uwp_tool') }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
  async fetchLatestCoreVersions(): Promise<
    Result<ManifestVersionLatest, string>
  > {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('fetch_latest_core_versions'),
      }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
  async updateCore(coreType: ClashCore): Promise<Result<number, string>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('update_core', { coreType }),
      }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
  async inspectUpdater(
    updaterId: number,
  ): Promise<Result<UpdaterSummary, string>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('inspect_updater', { updaterId }),
      }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
  async getCoreVersion(coreType: ClashCore): Promise<Result<string, string>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('get_core_version', { coreType }),
      }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
  async collectLogs(): Promise<Result<null, string>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('collect_logs') }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
  async getVergeConfig(): Promise<Result<IVerge, string>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('get_verge_config') }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
  async patchVergeConfig(payload: IVerge): Promise<Result<null, string>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('patch_verge_config', { payload }),
      }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
  async getProfiles(): Promise<Result<Profiles, string>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('get_profiles') }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
  async enhanceProfiles(): Promise<Result<null, string>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('enhance_profiles') }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
  /**
   * 修改profiles的
   */
  async patchProfilesConfig(
    profiles: ProfilesBuilder,
  ): Promise<Result<null, string>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('patch_profiles_config', { profiles }),
      }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
  async viewProfile(uid: string): Promise<Result<null, string>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('view_profile', { uid }) }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
  /**
   * update profile by uid
   */
  async patchProfile(
    uid: string,
    profile: ProfileBuilder,
  ): Promise<Result<null, string>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('patch_profile', { uid, profile }),
      }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
  /**
   * create a new profile
   */
  async createProfile(
    item: ProfileBuilder,
    fileData: string | null,
  ): Promise<Result<null, string>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('create_profile', { item, fileData }),
      }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
  async importProfile(
    url: string,
    option: RemoteProfileOptionsBuilder | null,
  ): Promise<Result<null, string>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('import_profile', { url, option }),
      }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
  async reorderProfile(
    activeId: string,
    overId: string,
  ): Promise<Result<null, string>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('reorder_profile', { activeId, overId }),
      }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
  async reorderProfilesByList(list: string[]): Promise<Result<null, string>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('reorder_profiles_by_list', { list }),
      }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
  async updateProfile(
    uid: string,
    option: RemoteProfileOptionsBuilder | null,
  ): Promise<Result<null, string>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('update_profile', { uid, option }),
      }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
  async deleteProfile(uid: string): Promise<Result<null, string>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('delete_profile', { uid }),
      }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
  async readProfileFile(uid: string): Promise<Result<string, string>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('read_profile_file', { uid }),
      }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
  async saveProfileFile(
    uid: string,
    fileData: string | null,
  ): Promise<Result<null, string>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('save_profile_file', { uid, fileData }),
      }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
  async saveWindowSizeState(): Promise<Result<null, string>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('save_window_size_state'),
      }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
  async getCustomAppDir(): Promise<Result<string | null, string>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('get_custom_app_dir') }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
  async setCustomAppDir(path: string): Promise<Result<null, string>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('set_custom_app_dir', { path }),
      }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
  async statusService(): Promise<Result<StatusInfo, string>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('status_service') }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
  async installService(): Promise<Result<null, string>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('install_service') }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
  async uninstallService(): Promise<Result<null, string>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('uninstall_service') }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
  async startService(): Promise<Result<null, string>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('start_service') }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
  async stopService(): Promise<Result<null, string>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('stop_service') }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
  async restartService(): Promise<Result<null, string>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('restart_service') }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
  async isPortable(): Promise<Result<boolean, string>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('is_portable') }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
  async getProxies(): Promise<Result<Proxies, string>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('get_proxies') }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
  async selectProxy(
    group: string,
    name: string,
  ): Promise<Result<null, string>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('select_proxy', { group, name }),
      }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
  async updateProxyProvider(name: string): Promise<Result<null, string>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('update_proxy_provider', { name }),
      }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
  async restartApplication(): Promise<Result<null, string>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('restart_application') }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
  async collectEnvs(): Promise<Result<EnvInfo, string>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('collect_envs') }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
  async getServerPort(): Promise<Result<number, string>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('get_server_port') }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
  async setTrayIcon(
    mode: TrayIcon,
    path: string | null,
  ): Promise<Result<null, string>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('set_tray_icon', { mode, path }),
      }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
  async isTrayIconSet(mode: TrayIcon): Promise<Result<boolean, string>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('is_tray_icon_set', { mode }),
      }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
  async getCoreStatus(): Promise<Result<[CoreState, number, RunType], string>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('get_core_status') }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
  async urlDelayTest(
    url: string,
    expectedStatus: number,
  ): Promise<Result<number | null, string>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('url_delay_test', { url, expectedStatus }),
      }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
  async getIpsbAsn(): Promise<Result<JsonValue, string>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('get_ipsb_asn') }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
  async openThat(path: string): Promise<Result<null, string>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('open_that', { path }) }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
  async isAppimage(): Promise<Result<boolean, string>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('is_appimage') }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
  async getServiceInstallPrompt(): Promise<Result<string, string>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('get_service_install_prompt'),
      }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
  async cleanupProcesses(): Promise<Result<null, string>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('cleanup_processes') }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
  async getStorageItem(key: string): Promise<Result<string | null, string>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('get_storage_item', { key }),
      }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
  async setStorageItem(
    key: string,
    value: string,
  ): Promise<Result<null, string>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('set_storage_item', { key, value }),
      }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
  async removeStorageItem(key: string): Promise<Result<null, string>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('remove_storage_item', { key }),
      }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
  async mutateProxies(): Promise<Result<Proxies, string>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('mutate_proxies') }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
  async getCoreDir(): Promise<Result<string, string>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('get_core_dir') }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
  async getClashWsConnectionsState(): Promise<
    Result<ClashConnectionsConnectorState, string>
  > {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('get_clash_ws_connections_state'),
      }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
}

/** user-defined events **/

export const events = __makeEvents__<{
  clashConnectionsEvent: ClashConnectionsEvent
}>({
  clashConnectionsEvent: 'clash-connections-event',
})

/** user-defined constants **/

/** user-defined types **/

export type BuildInfo = {
  app_name: string
  app_version: string
  pkg_version: string
  commit_hash: string
  commit_author: string
  commit_date: string
  build_date: string
  build_profile: string
  build_platform: string
  rustc_version: string
  llvm_version: string
}
export type ChunkStatus = {
  state: ChunkThreadState
  start: number
  end: number
  downloaded: number
  speed: number
}
export type ChunkThreadState = 'Idle' | 'Downloading' | 'Finished'
export type ClashConnectionsConnectorEvent =
  | { kind: 'state_changed'; data: ClashConnectionsConnectorState }
  | { kind: 'update'; data: ClashConnectionsInfo }
export type ClashConnectionsConnectorState =
  | 'disconnected'
  | 'connecting'
  | 'connected'
export type ClashConnectionsEvent = ClashConnectionsConnectorEvent
export type ClashConnectionsInfo = {
  downloadTotal: number
  uploadTotal: number
  downloadSpeed: number
  uploadSpeed: number
}
export type ClashCore =
  | 'clash'
  | 'clash-rs'
  | 'mihomo'
  | 'mihomo-alpha'
  | 'clash-rs-alpha'
export type ClashCoreType =
  | 'mihomo'
  | 'mihomo-alpha'
  | 'clash-rs'
  | 'clash-rs-alpha'
  | 'clash'
export type ClashInfo = {
  /**
   * clash core port
   */
  port: number
  /**
   * same as `external-controller`
   */
  server: string
  /**
   * clash secret
   */
  secret: string | null
}
export type ClashStrategy = {
  external_controller_port_strategy: ExternalControllerPortStrategy
}
export type CoreInfos = {
  type: CoreType | null
  state: CoreState
  state_changed_at: number
  config_path: string | null
}
export type CoreState = 'Running' | { Stopped: string | null }
export type CoreType = { clash: ClashCoreType } | 'singbox'
export type DelayRes = { delay: number }
export type DeviceInfo = {
  /**
   * Device name, such as "Intel Core i5-8250U CPU @ 1.60GHz x 8"
   */
  cpu: string[]
  /**
   * GPU name, such as "Intel UHD Graphics 620 (Kabylake GT2)"
   * Memory size in bytes
   */
  memory: string
}
export type DownloadStatus = {
  state: DownloaderState
  downloaded: number
  total: number
  speed: number
  chunks: ChunkStatus[]
  now: number
}
export type DownloaderState =
  | 'idle'
  | 'downloading'
  | 'waiting_for_merge'
  | 'merging'
  | { failed: string }
  | 'finished'
export type EnvInfo = {
  os: string
  arch: string
  core: Partial<{ [key in string]: string }>
  device: DeviceInfo
  build_info: BuildInfo
}
export type ExternalControllerPortStrategy =
  | 'fixed'
  | 'random'
  | 'allow_fallback'
export type GetSysProxyResponse = {
  enable: boolean
  host: string
  port: number
  bypass: string
  server: string
}
/**
 * ### `verge.yaml` schema
 */
export type IVerge = {
  /**
   * app listening port for app singleton
   */
  app_singleton_port: number | null
  /**
   * app log level
   * silent | error | warn | info | debug | trace
   */
  app_log_level: LoggingLevel | null
  language: string | null
  /**
   * `light` or `dark` or `system`
   */
  theme_mode: string | null
  /**
   * enable traffic graph default is true
   */
  traffic_graph: boolean | null
  /**
   * show memory info (only for Clash Meta)
   */
  enable_memory_usage: boolean | null
  /**
   * global ui framer motion effects
   */
  lighten_animation_effects: boolean | null
  /**
   * clash tun mode
   */
  enable_tun_mode: boolean | null
  /**
   * windows service mode
   */
  enable_service_mode?: boolean | null
  /**
   * can the app auto startup
   */
  enable_auto_launch: boolean | null
  /**
   * not show the window on launch
   */
  enable_silent_start: boolean | null
  /**
   * set system proxy
   */
  enable_system_proxy: boolean | null
  /**
   * enable proxy guard
   */
  enable_proxy_guard: boolean | null
  /**
   * set system proxy bypass
   */
  system_proxy_bypass: string | null
  /**
   * proxy guard interval
   */
  proxy_guard_interval: number | null
  /**
   * theme setting
   */
  theme_color: string | null
  /**
   * web ui list
   */
  web_ui_list: string[] | null
  /**
   * clash core path
   */
  clash_core?: ClashCore | null
  /**
   * hotkey map
   * format: {func},{key}
   */
  hotkeys: string[] | null
  /**
   * 切换代理时自动关闭连接
   */
  auto_close_connection: boolean | null
  /**
   * 默认的延迟测试连接
   */
  default_latency_test: string | null
  /**
   * 支持关闭字段过滤，避免meta的新字段都被过滤掉，默认为真
   */
  enable_clash_fields: boolean | null
  /**
   * 是否使用内部的脚本支持，默认为真
   */
  enable_builtin_enhanced: boolean | null
  /**
   * proxy 页面布局 列数
   */
  proxy_layout_column: number | null
  /**
   * 日志清理
   * 分钟数； 0 为不清理
   * @deprecated use `max_log_files` instead
   */
  auto_log_clean: number | null
  /**
   * 日记轮转时间，单位：天
   */
  max_log_files: number | null
  /**
   * window size and position
   * @deprecated use `window_size_state` instead
   */
  window_size_position?: number[] | null
  window_size_state?: WindowState | null
  /**
   * 是否启用随机端口
   */
  enable_random_port: boolean | null
  /**
   * verge mixed port 用于覆盖 clash 的 mixed port
   */
  verge_mixed_port: number | null
  /**
   * Check update when app launch
   */
  enable_auto_check_update: boolean | null
  /**
   * Clash 相关策略
   */
  clash_strategy: ClashStrategy | null
  /**
   * 是否启用代理托盘选择
   */
  clash_tray_selector: ProxiesSelectorMode | null
  always_on_top: boolean | null
  /**
   * Tun 堆栈选择
   * TODO: 弃用此字段，转移到 clash config 里
   */
  tun_stack: TunStack | null
  /**
   * 是否启用网络统计信息浮窗
   */
  network_statistic_widget?: NetworkStatisticWidgetConfig | null
}
export type JsonValue =
  | null
  | boolean
  | number
  | string
  | JsonValue[]
  | Partial<{ [key in string]: JsonValue }>
export type LocalProfile = {
  uid: string
  /**
   * profile item type
   * enum value: remote | local | script | merge
   */
  type: ProfileItemType
  /**
   * profile name
   */
  name: string
  /**
   * profile holds the file
   */
  file: string
  /**
   * profile description
   */
  desc: string | null
  /**
   * update time
   */
  updated: number
} & {
  /**
   * file symlinks
   */
  symlinks?: string | null
  /**
   * process chain
   */
  chain?: string[]
}
/**
 * Builder for [`LocalProfile`](struct.LocalProfile.html).
 *
 */
export type LocalProfileBuilder = {
  uid: string | null
  /**
   * profile item type
   * enum value: remote | local | script | merge
   */
  type: ProfileItemType | null
  /**
   * profile name
   */
  name: string | null
  /**
   * profile holds the file
   */
  file: string | null
  /**
   * profile description
   */
  desc: string | null
  /**
   * update time
   */
  updated: number | null
} & {
  /**
   * file symlinks
   */
  symlinks: string | null
  /**
   * process chain
   */
  chain?: string[] | null
}
export type LogSpan = 'log' | 'info' | 'warn' | 'error'
export type LoggingLevel =
  | 'silent'
  | 'trace'
  | 'debug'
  | 'info'
  | 'warn'
  | 'error'
export type ManifestVersionLatest = {
  mihomo: string
  mihomo_alpha: string
  clash_rs: string
  clash_rs_alpha: string
  clash_premium: string
}
export type MergeProfile = {
  uid: string
  /**
   * profile item type
   * enum value: remote | local | script | merge
   */
  type: ProfileItemType
  /**
   * profile name
   */
  name: string
  /**
   * profile holds the file
   */
  file: string
  /**
   * profile description
   */
  desc: string | null
  /**
   * update time
   */
  updated: number
}
/**
 * Builder for [`MergeProfile`](struct.MergeProfile.html).
 *
 */
export type MergeProfileBuilder = {
  uid: string | null
  /**
   * profile item type
   * enum value: remote | local | script | merge
   */
  type: ProfileItemType | null
  /**
   * profile name
   */
  name: string | null
  /**
   * profile holds the file
   */
  file: string | null
  /**
   * profile description
   */
  desc: string | null
  /**
   * update time
   */
  updated: number | null
}
export type NetworkStatisticWidgetConfig =
  | { kind: 'disabled' }
  | { kind: 'enabled'; value: StatisticWidgetVariant }
export type PatchRuntimeConfig = {
  allow_lan?: boolean | null
  ipv6?: boolean | null
  log_level?: string | null
  mode?: string | null
}
/**
 * 后处理输出
 */
export type PostProcessingOutput = {
  /**
   * 局部链的输出
   */
  scopes: Partial<{
    [key in string]: Partial<{ [key in string]: [LogSpan, string][] }>
  }>
  /**
   * 全局链的输出
   */
  global: Partial<{ [key in string]: [LogSpan, string][] }>
  /**
   * 根据配置进行的分析建议
   */
  advice: [LogSpan, string][]
}
export type Profile =
  | RemoteProfile
  | LocalProfile
  | MergeProfile
  | ScriptProfile
export type ProfileBuilder =
  | RemoteProfileBuilder
  | LocalProfileBuilder
  | MergeProfileBuilder
  | ScriptProfileBuilder
export type ProfileItemType =
  | 'remote'
  | 'local'
  | { script: ScriptType }
  | 'merge'
/**
 * Define the `profiles.yaml` schema
 */
export type Profiles = {
  /**
   * same as PrfConfig.current
   */
  current?: string[]
  /**
   * same as PrfConfig.chain
   */
  chain?: string[]
  /**
   * record valid fields for clash
   */
  valid?: string[]
  /**
   * profile list
   */
  items?: Profile[]
}
/**
 * Builder for [`Profiles`](struct.Profiles.html).
 *
 */
export type ProfilesBuilder = {
  /**
   * same as PrfConfig.current
   */
  current: string[] | null
  /**
   * same as PrfConfig.chain
   */
  chain: string[] | null
  /**
   * record valid fields for clash
   */
  valid: string[] | null
  /**
   * profile list
   */
  items: Profile[] | null
}
export type Proxies = {
  global: ProxyGroupItem
  direct: ProxyItem
  groups: ProxyGroupItem[]
  records: Partial<{ [key in string]: ProxyItem }>
  proxies: ProxyItem[]
}
export type ProxiesSelectorMode = 'hidden' | 'normal' | 'submenu'
export type ProxyGroupItem = {
  name: string
  type: string
  udp: boolean
  history: ProxyItemHistory[]
  all: ProxyItem[]
  now: string | null
  provider: string | null
  alive: boolean | null
  xudp?: boolean | null
  tfo?: boolean | null
  icon?: string | null
  hidden?: boolean
}
export type ProxyItem = {
  name: string
  type: string
  udp: boolean
  history: ProxyItemHistory[]
  all: string[] | null
  now: string | null
  provider: string | null
  alive: boolean | null
  xudp?: boolean | null
  tfo?: boolean | null
  icon?: string | null
  hidden?: boolean
}
export type ProxyItemHistory = { time: string; delay: number }
export type RemoteProfile = {
  uid: string
  /**
   * profile item type
   * enum value: remote | local | script | merge
   */
  type: ProfileItemType
  /**
   * profile name
   */
  name: string
  /**
   * profile holds the file
   */
  file: string
  /**
   * profile description
   */
  desc: string | null
  /**
   * update time
   */
  updated: number
} & {
  /**
   * subscription url
   */
  url: string
  /**
   * subscription user info
   */
  extra?: SubscriptionInfo
  /**
   * remote profile options
   */
  option?: RemoteProfileOptions
  /**
   * process chain
   */
  chain?: string[]
}
/**
 * Builder for [`RemoteProfile`](struct.RemoteProfile.html).
 *
 */
export type RemoteProfileBuilder = {
  uid: string | null
  /**
   * profile item type
   * enum value: remote | local | script | merge
   */
  type: ProfileItemType | null
  /**
   * profile name
   */
  name: string | null
  /**
   * profile holds the file
   */
  file: string | null
  /**
   * profile description
   */
  desc: string | null
  /**
   * update time
   */
  updated: number | null
} & {
  /**
   * subscription url
   */
  url: string | null
  /**
   * subscription user info
   */
  extra: SubscriptionInfo | null
  /**
   * remote profile options
   */
  option?: RemoteProfileOptionsBuilder
  /**
   * process chain
   */
  chain?: string[] | null
}
export type RemoteProfileOptions = {
  /**
   * see issue #13
   */
  user_agent?: string | null
  /**
   * for `remote` profile
   * use system proxy
   */
  with_proxy?: boolean | null
  /**
   * use self proxy
   */
  self_proxy?: boolean | null
  /**
   * subscription update interval
   */
  update_interval: number
}
/**
 * Builder for [`RemoteProfileOptions`](struct.RemoteProfileOptions.html).
 *
 */
export type RemoteProfileOptionsBuilder = {
  /**
   * see issue #13
   */
  user_agent: string | null
  /**
   * for `remote` profile
   * use system proxy
   */
  with_proxy: boolean | null
  /**
   * use self proxy
   */
  self_proxy: boolean | null
  /**
   * subscription update interval
   */
  update_interval: number | null
}
export type RunType =
  /**
   * Run as child process directly
   */
  | 'normal'
  /**
   * Run by Nyanpasu Service via a ipc call
   */
  | 'service'
  /**
   * Run as elevated process, if profile advice to run as elevated
   */
  | 'elevated'
export type RuntimeInfos = {
  service_data_dir: string
  service_config_dir: string
  nyanpasu_config_dir: string
  nyanpasu_data_dir: string
}
export type ScriptProfile = {
  uid: string
  /**
   * profile item type
   * enum value: remote | local | script | merge
   */
  type: ProfileItemType
  /**
   * profile name
   */
  name: string
  /**
   * profile holds the file
   */
  file: string
  /**
   * profile description
   */
  desc: string | null
  /**
   * update time
   */
  updated: number
}
/**
 * Builder for [`ScriptProfile`](struct.ScriptProfile.html).
 *
 */
export type ScriptProfileBuilder = {
  uid: string | null
  /**
   * profile item type
   * enum value: remote | local | script | merge
   */
  type: ProfileItemType | null
  /**
   * profile name
   */
  name: string | null
  /**
   * profile holds the file
   */
  file: string | null
  /**
   * profile description
   */
  desc: string | null
  /**
   * update time
   */
  updated: number | null
}
export type ScriptType = 'javascript' | 'lua'
export type ServiceStatus = 'not_installed' | 'stopped' | 'running'
export type StatisticWidgetVariant = 'large' | 'small'
export type StatusInfo = {
  name: string
  version: string
  status: ServiceStatus
  server: StatusResBody | null
}
export type StatusResBody = {
  version: string
  core_infos: CoreInfos
  runtime_infos: RuntimeInfos
}
export type SubscriptionInfo = {
  upload: number
  download: number
  total: number
  expire: number
}
export type TrayIcon = 'normal' | 'tun' | 'system_proxy'
export type TunStack = 'system' | 'gvisor' | 'mixed'
export type UpdaterState =
  | 'idle'
  | 'downloading'
  | 'decompressing'
  | 'replacing'
  | 'restarting'
  | 'done'
  | { failed: string }
export type UpdaterSummary = {
  id: number
  state: UpdaterState
  downloader: DownloadStatus
}
export type WindowState = {
  width: number
  height: number
  x: number
  y: number
  maximized: boolean
  fullscreen: boolean
}

type __EventObj__<T> = {
  listen: (
    cb: TAURI_API_EVENT.EventCallback<T>,
  ) => ReturnType<typeof TAURI_API_EVENT.listen<T>>
  once: (
    cb: TAURI_API_EVENT.EventCallback<T>,
  ) => ReturnType<typeof TAURI_API_EVENT.once<T>>
  emit: null extends T
    ? (payload?: T) => ReturnType<typeof TAURI_API_EVENT.emit>
    : (payload: T) => ReturnType<typeof TAURI_API_EVENT.emit>
}

export type Result<T, E> =
  | { status: 'ok'; data: T }
  | { status: 'error'; error: E }

function __makeEvents__<T extends Record<string, any>>(
  mappings: Record<keyof T, string>,
) {
  return new Proxy(
    {} as unknown as {
      [K in keyof T]: __EventObj__<T[K]> & {
        (handle: __WebviewWindow__): __EventObj__<T[K]>
      }
    },
    {
      get: (_, event) => {
        const name = mappings[event as keyof T]

        return new Proxy((() => {}) as any, {
          apply: (_, __, [window]: [__WebviewWindow__]) => ({
            listen: (arg: any) => window.listen(name, arg),
            once: (arg: any) => window.once(name, arg),
            emit: (arg: any) => window.emit(name, arg),
          }),
          get: (_, command: keyof __EventObj__<any>) => {
            switch (command) {
              case 'listen':
                return (arg: any) => TAURI_API_EVENT.listen(name, arg)
              case 'once':
                return (arg: any) => TAURI_API_EVENT.once(name, arg)
              case 'emit':
                return (arg: any) => TAURI_API_EVENT.emit(name, arg)
            }
          },
        })
      },
    },
  )
}
